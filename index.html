
  <!DOCTYPE html>
  <html lang="en">
    <head>
     <script src="https://telegram.org/js/telegram-web-app.js"></script>
      <meta charset="UTF-8" />
      <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <title>Макет приложения для Telegram (Copy) (Copy)</title>
    </head>

    <script>
(function () {
  const API_BASE = (window?.import?.meta && window.import.meta.env?.VITE_API_BASE_URL) || "https://hui-production.up.railway.app";

  // маленький помощник: находит в модалке элементы
  function findAdminModalElements(root) {
    // Поле ID: сначала пробуем input[type=number], потом по placeholder/label
    const idInput =
      root.querySelector('input[type="number"]') ||
      [...root.querySelectorAll('input,textarea')].find(el =>
        /telegram\s*id|id/i.test(el.placeholder || el.ariaLabel || "")
      );

    // Поле пароль: input[type=password] или по placeholder/label
    const passInput =
      root.querySelector('input[type="password"]') ||
      [...root.querySelectorAll('input,textarea')].find(el =>
        /парол|password|код доступа/i.test(el.placeholder || el.ariaLabel || "")
      );

    // Кнопка войти: по тексту
    const loginBtn =
      [...root.querySelectorAll('button,[role="button"],input[type="submit"]')].find(el =>
        /войти|login|админ/i.test((el.innerText || el.value || "").trim())
      );

    // Блок для ошибок (если есть) — иначе создадим сами
    let errorBox =
      root.querySelector('[data-admin-error]') ||
      [...root.querySelectorAll('*')].find(el => /ошиб|error/i.test(el.className || el.id || ""));

    if (!errorBox) {
      errorBox = document.createElement('div');
      errorBox.setAttribute('data-admin-error', '1');
      errorBox.style.cssText = "color:#c00;font-size:12px;margin-top:8px;";
      // вставим рядом с кнопкой
      loginBtn && loginBtn.parentElement && loginBtn.parentElement.appendChild(errorBox);
    }

    return { idInput, passInput, loginBtn, errorBox };
  }

  // навешиваем обработчик один раз
  function attachLoginHandler(modalRoot) {
    const { idInput, passInput, loginBtn, errorBox } = findAdminModalElements(modalRoot);
    if (!idInput || !passInput || !loginBtn) return false;
    if (loginBtn.__gritherBound) return true; // уже навешан

    async function doLogin(e) {
      e?.preventDefault?.();
      errorBox && (errorBox.textContent = "");
      const idNum = Number(String(idInput.value || "").trim());
      const pwd = String(passInput.value || "").trim();
      if (!idNum || !pwd) {
        if (errorBox) errorBox.textContent = "Введите Telegram ID и пароль";
        return;
      }
      try {
        const rsp = await fetch(`${API_BASE}/api/admin/login`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ tg_user_id: idNum, password: pwd })
        });
        const data = await rsp.json().catch(() => ({}));
        if (!rsp.ok || !data?.ok) {
          if (errorBox) errorBox.textContent = (data?.error === "bad_credentials")
            ? "Неверный ID или пароль"
            : "Ошибка входа";
          return;
        }
        localStorage.setItem("grither_admin_token", data.token);
        localStorage.setItem("grither_admin_role", data.role);
        // можно закрыть модалку — пробуем кликнуть по кнопке закрытия, если есть
        const closeBtn = modalRoot.querySelector('[data-close], [aria-label="Close"], .close, [data-state="open"]~button');
        closeBtn && closeBtn.click();
        // уведомим приложение (если кто-то слушает)
        window.dispatchEvent(new CustomEvent("grither:admin:login", { detail: { role: data.role } }));
      } catch {
        if (errorBox) errorBox.textContent = "Сеть недоступна";
      }
    }

    loginBtn.addEventListener('click', doLogin);
    passInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') doLogin(e); });
    loginBtn.__gritherBound = true;
    return true;
  }

  // Следим за появлением модалки в DOM
  const obs = new MutationObserver((muts) => {
    for (const m of muts) {
      for (const node of m.addedNodes) {
        if (!(node instanceof HTMLElement)) continue;
        // ищем большие оверлеи/диалоги
        if (node.matches?.('dialog,[role="dialog"],[data-state="open"],.fixed,.modal,.overlay')) {
          attachLoginHandler(node);
        }
        // и глубже
        node.querySelectorAll?.('dialog,[role="dialog"],[data-state="open"],.fixed,.modal,.overlay')
          .forEach(el => attachLoginHandler(el));
      }
    }
  });

  obs.observe(document.documentElement, { childList: true, subtree: true });
})();
</script>

    
    <body>
      <div id="root"></div>
     <!-- Авто-авторизация в Telegram WebApp -->
    <!-- Диагностический маяк + авторизация через Telegram WebApp (с фолбэком) -->
<script>
(function () {
  // 0) Маяк: загрузка страницы
  new Image().src = 'https://hui-production.up.railway.app/api/twa/ping?from=indexhtml&ts=' + Date.now();

  try {
    var wa = window.Telegram && Telegram.WebApp;
    new Image().src = 'https://hui-production.up.railway.app/api/twa/ping?wa=' + (wa ? 1 : 0);
    if (!wa) return;

    // чуть «раскрываем» WebApp и помечаем готовность
    try { wa.ready(); wa.expand(); } catch (e) {}

    // 1) если есть «настоящий» initData — используем его
    var hasInit = !!(wa.initData && wa.initData.length > 10);
    new Image().src = 'https://hui-production.up.railway.app/api/twa/ping?init=' + (hasInit ? 1 : 0);

    // 2) если initData пуст, соберём фолбэк из initDataUnsafe.user (это ок, пока SKIP_TWA_VERIFY=1 на бэке)
    var initDataToSend;
    if (hasInit) {
      initDataToSend = wa.initData;
    } else {
      var unsafeUser = (wa.initDataUnsafe && wa.initDataUnsafe.user) || null;
      if (!unsafeUser) return; // вообще нет данных — выходим
      var u = encodeURIComponent(JSON.stringify(unsafeUser));
      // формируем "псевдо-initData" (хеш фиктивный — в diag-режиме сервер примет)
      initDataToSend = 'query_id=x&user=' + u + '&auth_date=0&hash=0';
    }

  
    .then(function(r){ return r.json(); })
    .then(function(r){
      new Image().src = 'https://hui-production.up.railway.app/api/twa/ping?auth=' + (r && r.ok ? 'ok' : 'fail');
      if (r && r.ok) {
        localStorage.setItem('grither_token', r.token || '');
        localStorage.setItem('grither_me', JSON.stringify(r.me || {}));
      }
    })
    .catch(function(){ /* ignore */ });

  } catch (e) {
    new Image().src = 'https://hui-production.up.railway.app/api/twa/ping?err=1';
  }
})();
</script>


<script>
(function () {
  try {
    var wa = window.Telegram && Telegram.WebApp;
    if (!wa || !wa.initData) return; // если открыто НЕ из Telegram — тихо выходим

    // ПИНГ ДЛЯ ПРОВЕРКИ СВЯЗИ (увидишь в HTTP Logs)
    fetch('https://hui-production.up.railway.app/api/twa/ping?from=netlify-indexhtml')
      .catch(function(){});

    // Сама авторизация
    fetch('https://hui-production.up.railway.app/api/twa/auth', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ initData: wa.initData })
    })
      .then(function(r){ return r.json(); })
      .then(function(r){
        // чтобы видеть прямо в вебвью
        try { console.log('AUTH RESULT', r); } catch(e) {}
        if (r && r.ok) {
          localStorage.setItem('grither_token', r.token || '');
          localStorage.setItem('grither_me', JSON.stringify(r.me || {}));
        }
      })
      .catch(function(){});
  } catch (e) {
    try { console.log('AUTH ERROR', e && e.message); } catch (_){}
  }
})();
</script>

      <script type="module" src="/src/main.tsx"></script>
    </body>
  </html>
  
